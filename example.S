.data # сегмент данных
buf:
.byte 0
.ascii "66785608"# строка, которую мы переводим в число
buf1:
.byte 0
msg:
.ascii "Преобразование прошло успешно\n"
len = . - msg # длина сообщения

.text # сегмент кода
.globl _start
_start:
 mov $buf1, %r8
 dec %r8 # указывает на младший разряд числа
 mov $buf, %r9 # последний разряд числа
 xor %r10, %r10 # здесь будет копиться сумма
 mov $1, %r11 # в начале умножаем на 1, потом на 10 и т. д.
lo:
 cmp %r8, %r9 # конец вычислениям
 jz ex # выход из цикла
 xor %rax, %rax # обнулить регистр для выполнения умножения
 mov (%r8), %al # код символа цифры
 sub $48, %al # символ цифры в цифру
 mul %r11 # умножаем r11 на rax, результат в rax
 add %rax, %r10 # накапливаем в r10
 mov %r11, %rax # множитель в rax
 mov $10, %rcx # будем умножать на 10
 mul %rcx #
 mov %rax, %r11 # результат в r11 (1, 10, 100 и т. д.)
 dec %r8 # к следующему символу
 jmp lo # к началу цикла
ex:
# а здесь просто проверка того, что мы правильно
# перевели строку в число
 cmp $66785608, %r10
 jnz en
tm:
# сообщение, что преобразование прошло успешно
 mov $1, %rdi # stdout
 mov $msg, %rsi # адрес сообщения

  mov $len, %rdx # длина сообщения
 mov $1, %rax # номер системного вызова для вывода на консоль
 syscall # системный вызов
# закончить работу программы
en:
 mov $60, %rax # номер системного вызова exit
 xor %rdi, %rdi # код возврата (0 - выход без ошибок)
 syscall # системный вызов